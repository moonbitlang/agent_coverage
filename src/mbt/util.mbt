///|
pub let moonbitlang_core = "moonbitlang/core"

///|
pub fn fn_name(toplevel : Toplevel) -> String? {
  let rest = for ln in @text.split_lines(toplevel) {
    let rest_segments = ln.split(" ").drop(1).to_array()
    let rest = String::concat(separator=" ", rest_segments)
    if not(rest.starts_with("//")) {
      break rest
    }
  } else {
    ""
  }
  @jsext.Re::new(
    #|(?:fn|impl.*?with) +([\w:&]+)[([]
    ,
  )
  .match_(rest)
  .get(1)
}

///| Extracts imports of a certain package from its `.mbti` manifest
/// generated by `moon info` (with or without --no-alias`).
/// This function assumes that each occurrence of `@foo/bar/baz.Qux`
/// indicates a corresponding import of the package named `foo/bar/baz`.
pub fn imports_from_mbti(mbti_text : String) -> Set[String] {
  // A set of known short names for imports.
  let seen = Set::new()
  let res = Set::of(["moonbitlang/core/builtin"])
  let matches = @jsext.Re::new(
    flags="g",
    #|@([\w/]+)\.|alias @([\w/]+) as @([\w/]+)
    ,
  ).match_all(mbti_text)
  for m in matches {
    // This name (`m[1]`) could be an import,
    // unless it has been seen in an `alias ... as @this/name`.
    for m1 in m.get(1) {
      if not(seen.contains(m1)) {
        res.add(m1)
      }
    }
    // In `alias @this/m2 as @m3`, `@this/m2` is definitely a new import.
    // At the same time, we should register `@m3` as seen as well.
    for m2 in m.get(2) {
      res.add(m2)
      seen.add(m[3])
    }
  }
  res
}

///|
pub fn is_fully_covered(readable_coverage_toplevel : Toplevel) -> Bool {
  not(
    @text.split_lines(readable_coverage_toplevel)
    .iter()
    .map(String::trim_space)
    .any(fn(ln) {
      ln
      .split(" ")
      .head()
      .unwrap()
      .trim_space()
      .ends_with(@prompt.UNCOVERED_MARKER)
    }),
  )
}

///|
pub fn moon_core_path() -> String {
  match @jsext.env("MOON_CORE_OVERRIDE") {
    Some(o) => o
    None => @path.join([moon_home_path(), "lib", "core"])
  }
}

///|
pub fn moon_home_path() -> String {
  match @jsext.env("MOON_HOME") {
    Some(o) => o
    None => @path.join([@jsext.home_dir(), ".moon"])
  }
}

///|
pub fn moonfmt!(src_text : String) -> String {
  let raw_res : @js.Value = spawn_sync_ffi(
    "moonfmt",
    ["-"],
    @js.Object(
      @json.from_json!({ "input": src_text.to_json(), "stdio": "pipe" }),
    ),
  ).get_with_string("stdout")
  guard not(raw_res.is_undefined()) else { "" }
  raw_res.to_string()
}

///|
pub fn toplevel_lines(src_text : String) -> Array[ToplevelLines] {
  let segments = @jsext.Re::new(
    flags="s",
    #|((?:(?:\/\/[^\n]*\n)+|\n|^)(?:(?:pub|priv|pub\(readonly\)) +)*(?:fn|let|type|struct|enum|test|impl))
    ,
  ).split(src_text)
  let segment_count = segments.length()
  guard segment_count >= 3 else { [] }
  let res = [
    @text.split_lines(segments[0]).to_array(), // File header
    @text.split_lines(String::concat(segments[1:3].iter().to_array())).to_array(),
  ]
  for i = 3; i < segment_count; i = i + 2 {
    let delimiter = segments[i]
    let structure = segments[i + 1]
    let curr_lines = @text.split_lines(delimiter + structure)
    let mut j = 0
    for ln in curr_lines {
      guard ln.is_blank() else { continue }
      res.last().unwrap().push(ln)
      j += 1
    }
    res.push(curr_lines[j:].iter().to_array())
  }
  res
}

///|
pub fn toplevels(src_text : String) -> Array[Toplevel] {
  (match toplevel_lines(src_text) {
    [[""], .. rest] | [.. rest] => rest
  }).map(fn(lns) { lns.join("\n") })
}
