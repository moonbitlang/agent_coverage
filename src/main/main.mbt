///|
enum CommitMode {
  None
  WriteFile
  GitStage
  GitCommit
} derive(Eq, Compare)

///|
async fn async_main() -> Unit! {
  dotenv_init()
  log_init()
  let proj = @mbt.Project::new(@jsext.env("AGENT_COVERAGE_PROJECT").unwrap())
  @log.g().info("starting agent on project: \{proj.cwd}")
  let model = model_from_env()
  @log.g().info("using model: \{model.model}")
  let llm = @agent.Polyglot::new(model)
  // TODO: Implement cachedFetchText
  let agent = @agent.Agent::{ llm, project: proj }
  let old_cov_data = proj.coverage_data!()
  let old_cov = old_cov_data.summary()
  let src_files = {
    let mut src_files = old_cov_data.source_files
      .keys()
      .filter(fn(s) { old_cov[s] is Some(cov) && cov < 1 })
      .to_array()
      ..sort_by_key(fn(s) { old_cov[s] })
    let mut src_file_count : Int? = None
    if @jsext.env("AGENT_COVERAGE_PROJECT_SOURCE_FILES") is Some(raw_src_files) &&
      not(raw_src_files.is_blank()) {
      src_file_count = @strconv.parse_int?(raw_src_files).to_option()
      if src_file_count is None {
        src_files = parse_file_list(raw_src_files)
      }
    }
    if @jsext.env("AGENT_COVERAGE_PROJECT_SKIPPED_FILES")
      is Some(raw_skipped_files) &&
      not(raw_skipped_files.is_blank()) {
      let skipped_files = Set::from_array(parse_file_list(raw_skipped_files))
      src_files = src_files.filter(fn(f) { not(skipped_files.contains(f)) })
    }
    if src_file_count is Some(count) {
      src_files.resize(count, "")
    }
    @log.g().info(
      "starting agent on source files:" +
      src_files
      .map(fn(s) { (s, old_cov.get(s).or(@double.not_a_number)) })
      .to_string(),
    )
    src_files
  }
  let initial_gas = @jsext.env("AGENT_COVERAGE_INITIAL_GAS")
    .bind(fn(g) { @strconv.parse_int?(g).to_option() })
    .or(3)
  let { additions, coverage_data: new_cov, .. } = agent.generate_test_cases_with_initial_gas!!(
    src_files~,
    initial_gas~,
  )
  fn percentage(c : Double) -> String {
    let round_prec = 0.001
    $|\{(c * 100 / round_prec).round() * round_prec}%
  }

  for s, c in new_cov.summary() {
    try {
      guard old_cov[s] is Some(c0) &&
        c0 < c &&
        additions[s] is Some(addition_toplevels) else {
        continue
      }
      let addition = addition_toplevels.join("\n\n")
      @log.g().info("generated additions for `{s}`:\n{addition}")
      let coverage_improvement = "coverage of \{s}: \{percentage(c0)} -> \{percentage(c)}"
      @log.g().info("generated additions for `\{s}`:\n\{addition}")
      let commit_mode = {
        let raw_commit_mode = @jsext.env("AGENT_COVERAGE_COMMIT_MODE")
          .or("")
          .to_lower()
        match raw_commit_mode {
          "" => None
          "commit" => GitCommit
          "stage" => GitStage
          _ => WriteFile
        }
      }
      if commit_mode >= WriteFile {
        let commit_path = @path.with_name(s, fn(name) { name + "_test" })
        @log.g().info("committing the additions to `\{commit_path}`")
        let commit_path_abs = @path.join([proj.cwd, commit_path])
        let original = @fs.read_file_to_string?(commit_path_abs)
          .to_option()
          .map_or("", fn(s) { s + "\n" })
        @fs.write_string_to_file!(commit_path_abs, original + addition)
        if commit_mode >= GitStage {
          let inherit_stdio = { "stdio": "inherit" }.iter2()
          @log.g().info("staging \{commit_path} to git...")
          let _ = proj.run("git", ["add", commit_path], opts=inherit_stdio)
          if commit_mode >= GitCommit {
            let curr_branch = (
                proj
                .run("git", ["rev-parse", "--abbrev-ref", "HEAD"])
                .get_with_string("stdout") : @js.Optional[@js.Value])
              .to_option()
              .unwrap()
              .to_string()
            let commit_branch_name = "`agent_coverage/cov-" +
              @jsext.Re::new("[/.]", flags="g").replace_all(s, "-") +
              "`"
            @log.g().info(
              "committing the previous changes to git in branch \{commit_branch_name}...",
            )
            let _ = proj.run(
              "git",
              ["checkout", "-b", commit_branch_name],
              opts=inherit_stdio,
            )
            let commit_message =
              $|test: improve coverage for `\{s}`
              #|
              #|**Disclaimer:** This PR was generated by an LLM agent as part of an experiment.
              #|
              #|## Summary
              #|
              #|```
              $|\{coverage_improvement}
              #|```
            let _ = proj.run(
              "git",
              ["commit", "-F", "-"],
              opts={ "input": commit_message }.iter2(),
            )
            let _ = proj.run("git", ["switch", curr_branch], opts=inherit_stdio)

          }
        }
      }
    } catch {
      e => {
        @log.g().fatal(
          "failed to collect test case generation result at entry \{s}: \{e}",
        )
        @log.g().error("old coverage data: \{old_cov}")
        @log.g().error("new coverage data: \{new_cov.summary()}")
        @log.g().error("additions: \{additions}")
      }
    }
  }
}

///|
fn parse_file_list(file_list : String) -> Array[String] {
  @jsext.Re::new(
    #|,\s*
    ,
  )
  .split(file_list)
  .filter_map(fn(f) {
    let trimmed = f.trim_space()
    if trimmed.is_empty() || trimmed.starts_with("#") {
      None
    } else {
      Some(trimmed)
    }
  })
}

///|
fn dotenv_init() -> Unit {
  @js.require("dotenv", keys=["config"]).cast()()
}

///|
fn log_init() -> Unit {
  guard not(@jsext.env("AGENT_COVERAGE_USE_OTEL") is (None | Some("0"))) &&
    @jsext.env("OTEL_EXPORTER_OTLP_LOGS_ENDPOINT") is Some(otlp_endpoint) else {
    @log.g() |> ignore
  }
  @log.g(
    logger=@log.OtelLogger::new(
      @log.Trace,
      service_name="agent_coverage",
      otlp_endpoint~,
    ),
  )
  |> ignore
}

///|
fn model_from_env() -> @agent.Model {
  let api_key = @jsext.env("OPENAI_API_KEY").or("")
  if api_key.is_blank() {
    @log.g().warn(
      "found empty $OPENAI_API_KEY, LLM responses might not work properly",
    )
  }
  let mut model = @jsext.env("AGENT_COVERAGE_LLM_MODEL").or("")
  if model.is_blank() {
    model = "anthropic/claude-3.7-sonnet"
    @log.g().warn(
      "found empty $AGENT_COVERAGE_LLM_MODEL, using default model \{model}",
    )
  }
  {
    base_url: @jsext.env("OPENAI_API_ENDPOINT").or(
      "https://openrouter.ai/api/v1",
    ),
    api_key,
    model,
    name: @path.basename(model),
    description: None,
  }
}

///|
fn main {
  @js.async_run(async fn() {
    try {
      async_main!!()
    } catch {
      e => println("ERROR: \{e}")
    }
  })
}
